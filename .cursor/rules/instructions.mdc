---
description: Правила решения issues, errors.
globs: *.tsx
---
# Структурированный подход к решению проблем

## 0. Технологический стек и требования проекта

### 0.1 Ключевые технологии
```markdown
Основные технологии:
- Next.js 15 (App Router, Server Components)
- TypeScript (строгая типизация)
- Prisma (ORM)
- React (Client Components)
- HeroUI (компонентная библиотека)

Дополнительные технологии:
- next-intl (интернационализация)
- next-auth (аутентификация)
- Tailwind CSS (стилизация)
- Zod (валидация)
- React Hook Form (формы)
```

### 0.2 Архитектурные принципы
```markdown
1. Типизация:
   - Строгая типизация TypeScript
   - Никаких any, кроме крайней необходимости
   - Интерфейсы для всех пропсов компонентов
   - Типы для всех API ответов
   - Zod схемы для валидации данных

2. Компонентная структура:
   - Серверные компоненты по умолчанию
   - "use client" только где необходимо
   - Атомарные компоненты в /components
   - Страницы в /app/[locale]
   - Layouts для повторяющихся элементов

3. Стилизация:
   - Tailwind CSS для стилей
   - HeroUI компоненты
   - Консистентные отступы и цвета
   - Темная тема через next-themes
   - Адаптивный дизайн

4. Данные и API:
   - Prisma для работы с БД
   - Серверные экшены для мутаций
   - API роуты в /app/api
   - Кэширование где возможно
   - Оптимистичные обновления UI
```

### 0.3 Правила и конвенции
```markdown
1. Именование:
   - PascalCase для компонентов
   - camelCase для функций и переменных
   - UPPER_CASE для констант
   - kebab-case для файлов стилей
   - Префикс I для интерфейсов (IProps)
   - Суффикс Type для типов

2. Структура файлов:
   - Один компонент - один файл
   - Группировка по фичам
   - Переиспользуемые компоненты в /components
   - Утилиты в /utils
   - Хуки в /hooks

3. Импорты:
   - Абсолютные импорты (@/)
   - Группировка импортов
   - Порядок: React, Next.js, внешние, внутренние

4. Типизация:
   - interface вместо type где возможно
   - Generics для переиспользуемых типов
   - Строгие типы для API
   - Документация для сложных типов
```

### 0.4 Проверки качества кода
```markdown
1. TypeScript:
   - strict: true
   - noImplicitAny: true
   - strictNullChecks: true
   - strictFunctionTypes: true

2. ESLint:
   - next/core-web-vitals
   - typescript-eslint
   - prettier интеграция
   - import сортировка

3. Тестирование:
   - Jest для unit тестов
   - Cypress для E2E
   - React Testing Library
   - Тесты для утилит и хуков

4. Performance:
   - Lighthouse метрики
   - Core Web Vitals
   - Bundle size оптимизация
   - Изображения через next/image
```

## 1. Сбор информации

### 1.1 Анализ структуры проекта
```bash
# Используем list_dir для понимания архитектуры
list_dir src/
list_dir src/app/
# При необходимости углубляемся в конкретные директории
```

### 1.2 Поиск связанных файлов
```bash
# Используем codebase_search для семантического поиска
codebase_search "релевантный поисковый запрос"
# Ищем связанные компоненты, хуки, утилиты
```

### 1.3 Поиск конкретных паттернов
```bash
# Используем grep_search для точного поиска
grep_search "конкретный паттерн"
# Ищем использование определенных функций, импортов, типов
```

### 1.4 Анализ содержимого файлов
```bash
# Используем read_file для детального изучения кода
read_file "path/to/file.ts"
# Изучаем реализацию, зависимости, типы
```

## 2. Структура анализа проблемы

### 2.1 Контекст проекта
```markdown
Проект:
- Next.js 15 приложение
- TypeScript + Prisma + HeroUI
- Интернационализация через next-intl
- Аутентификация через next-auth
- Строгая типизация и консистентность

Особенности:
- Server-first подход
- Строгая типизация
- Компонентная архитектура
- Интернационализация
- Производительность
```

### 2.2 Описание проблемы
```markdown
Проблема:
- Суть проблемы
- Текст ошибки (если есть)
- Текущее поведение
- Ожидаемое поведение
- Влияние на типизацию
- Влияние на производительность
- Влияние на SEO (если relevant)
```

### 2.3 Анализ затронутых частей
```markdown
Затронутые файлы (найдены через codebase_search):
- Основные файлы
- Связанные компоненты
- Затронутые типы/интерфейсы
- Конфигурационные файлы
- Схемы Prisma
- Файлы локализации
- Типы API

Зависимости (найдены через grep_search):
- Прямые зависимости
- Косвенные зависимости
- Версии библиотек
- Типы из @types
- Внутренние зависимости

Структура (найдена через list_dir):
- Иерархия файлов
- Организация кода
- Связи между модулями
- Структура API
- Структура компонентов
```

### 2.4 План решения
```markdown
Необходимые изменения:
1. [Изменение 1]
   - Файлы для изменения
   - Конкретные правки
   - Возможные побочные эффекты
   - Влияние на типы
   - Влияние на производительность

2. [Изменение 2]
   - Файлы для изменения
   - Конкретные правки
   - Возможные побочные эффекты
   - Влияние на типы
   - Влияние на производительность

Порядок выполнения:
1. Обновление типов и интерфейсов
2. Обновление компонентов
3. Обновление API и серверной логики
4. Обновление тестов
5. Проверка типов и линтинг
6. Проверка производительности
```

## 3. Применение решения

### 3.1 Внесение изменений
```bash
# Проверяем типы перед изменениями
tsc --noEmit

# Используем edit_file для внесения изменений
edit_file "path/to/file.ts"

# Обновляем типы
edit_file "types/file.ts"

# Обновляем API если нужно
edit_file "app/api/route.ts"

# Обновляем тесты
edit_file "__tests__/file.test.ts"
```

### 3.2 Проверка результата
```markdown
Проверки:
1. TypeScript:
   - tsc --noEmit
   - Отсутствие any
   - Корректные типы
   - Отсутствие type assertions

2. Линтер:
   - next lint
   - eslint-plugin-import
   - prettier

3. Тесты:
   - Unit тесты (Jest)
   - Компонентные тесты (RTL)
   - E2E тесты (Cypress)

4. Производительность:
   - Lighthouse
   - Core Web Vitals
   - Bundle size
   - Server Components

5. Функциональность:
   - Server-side
   - Client-side
   - SSR/SSG
   - API endpoints

6. Интернационализация:
   - Все строки в i18n
   - Форматирование дат/чисел
   - RTL поддержка
```

## 4. Документирование решения

### 4.1 Итоговый отчет
```markdown
Решение:
1. Внесенные изменения:
   - Изменения в типах
   - Изменения в компонентах
   - Изменения в API
   - Изменения в тестах

2. Причины изменений:
   - Технические причины
   - Бизнес-требования
   - Улучшение типизации
   - Оптимизация производительности

3. Возможные альтернативы:
   - Альтернативные подходы
   - Причины выбора решения
   - Trade-offs

4. Рекомендации:
   - По дальнейшей поддержке
   - По мониторингу
   - По оптимизации
   - По масштабированию
```

## 5. Специфичные для проекта проверки

### 5.1 Типизация
```markdown
1. TypeScript:
   - Строгие типы везде
   - Zod схемы для API
   - Prisma типы
   - React.FC<Props>
   - Enum вместо union types
   - Readonly где возможно

2. API:
   - Request/Response типы
   - Error handling
   - Validation
   - Status codes

3. Компоненты:
   - Props интерфейсы
   - Event handlers
   - Ref types
   - Children types
```

### 5.2 Производительность
```markdown
1. Server Components:
   - Минимум client-side JS
   - Правильное разделение
   - Suspense boundaries

2. Данные:
   - Кэширование
   - Revalidation
   - Prefetching
   - Optimistic updates

3. Сборка:
   - Bundle size
   - Tree shaking
   - Code splitting
   - Image optimization
```

## Примечания

1. Всегда начинать со сбора полной информации
2. Использовать инструменты в правильном порядке
3. Документировать все находки и решения
4. Проверять побочные эффекты
5. Следовать плану решения
6. Верифицировать результаты
7. Соблюдать типизацию
8. Оптимизировать производительность
9. Поддерживать консистентность кода
10. Следовать архитектурным принципам проекта

## Правила внесения изменений при рефакторинге

1. Уверенность в изменениях:
   - Вносить только те изменения, в успехе которых уверены на 99%
   - Изменения не должны ломать существующую функциональность
   - Изменения не должны ухудшат внешний вид системы
  
   -
   - При отсутствии высокой уверенности - обязательно сообщать пользователю:
     - О необходимости изменений
     - О возможных рисках
     - О предполагаемых временных затратах
     - О возможных альтернативных решениях

2. Оценка рисков:
   - Анализировать влияние на существующий код
   - Оценивать возможность отката изменений
   - Учитывать зависимости между компонентами
   - Проверять совместимость с текущей версией Next.js

3. Поэтапное внедрение:
   - Начинать с минимальных безопасных изменений
   - Проверять каждое изменение перед следующим
   - Иметь план отката изменений
   - Документировать каждый шаг

4. Коммуникация с пользователем:
   - Четко объяснять необходимость изменений
   - Предоставлять оценку времени
   - Описывать возможные риски
   - Предлагать альтернативные решения

Всегда используй. 
codebase_search - найти связанные файлы
grep_search - найти конкретные паттерны использования
list_dir - понять структуру проекта
read_file - проверить содержимое конкретных файлов


Не галюцинируй и не додумывай структуру проекта. Всегда прогружай и сознавай рабочую среду перед внесением изменений в код.

Перед началом работы с технологиями типа Next.js 15 консолидируй и обновляй информацию из онлайн-документации, четко следуй инструкциям. Информация из документация в приоритете перед твоими знаниями о субъекте.

Тщательно впитывай документацию и гайдлайны перед началом работы.